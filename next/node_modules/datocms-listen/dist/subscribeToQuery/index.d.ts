import type * as GraphQLWeb from "@0no-co/graphql.web";
/** A GraphQL `DocumentNode` with attached generics for its result data and variables.
 *
 * @remarks
 * A GraphQL {@link DocumentNode} defines both the variables it accepts on request and the `data`
 * shape it delivers on a response in the GraphQL query language.
 *
 * To bridge the gap to TypeScript, tools may be used to generate TypeScript types that define the shape
 * of `data` and `variables` ahead of time. These types are then attached to GraphQL documents using this
 * `TypedDocumentNode` type.
 *
 * Using a `DocumentNode` that is typed like this will cause any `urql` API to type its input `variables`
 * and resulting `data` using the types provided.
 *
 * @privateRemarks
 * For compatibility reasons this type has been copied and internalized from:
 * https://github.com/dotansimha/graphql-typed-document-node/blob/3711b12/packages/core/src/index.ts#L3-L10
 *
 * @see {@link https://github.com/dotansimha/graphql-typed-document-node} for more information.
 */
export declare type TypedDocumentNode<Result = {
    [key: string]: any;
}, Variables = {
    [key: string]: any;
}> = GraphQLWeb.DocumentNode & {
    /** Type to support `@graphql-typed-document-node/core`
     * @internal
     */
    __apiType?: (variables: Variables) => Result;
    /** Type to support `TypedQueryDocumentNode` from `graphql`
     * @internal
     */
    __ensureTypesOfVariablesAndResultMatching?: (variables: Variables) => Result;
};
export declare type UpdateData<QueryResult> = {
    /** The raw GraphQL response */
    response: {
        /** GraphQL response `data` property */
        data: QueryResult;
    };
};
export declare type ChannelErrorData = {
    /** The code of the error (ie. `INVALID_QUERY`) */
    code: string;
    /** An human friendly message explaining the error */
    message: string;
    /** If the error is not fatal (ie. the query is invalid), the query will be retried after some time */
    fatal: boolean;
    /** The raw error response, if available */
    response?: any;
};
export declare type ConnectionStatus = "connecting" | "connected" | "closed";
export declare type EventData = {
    /** The current status of the connection **/
    status: ConnectionStatus;
    /** The current channelUrl **/
    channelUrl: string;
    /** An event description **/
    message: string;
    /** Complete HTTP response */
    response: Response;
};
export declare type Options<QueryResult, QueryVariables> = {
    /** The GraphQL query to subscribe, or a TypedDocumentNode */
    query: string | TypedDocumentNode<QueryResult, QueryVariables>;
    /** GraphQL variables for the query */
    variables?: QueryVariables;
    /** DatoCMS API token to use */
    token: string;
    /**
     * If true, the Content Delivery API with draft content will be used
     * @deprecated use includeDrafts instead
     **/
    preview?: boolean;
    /** If true, draft records will be returned */
    includeDrafts?: boolean;
    /** If true, invalid records will be filtered out */
    excludeInvalid?: boolean;
    /** The name of the DatoCMS environment where to perform the query (defaults to primary environment) */
    environment?: string;
    /** In case of network errors, the period to wait to reconnect */
    reconnectionPeriod?: number;
    /** The fetch function to use to perform the registration query */
    fetcher?: (input: RequestInfo, init?: RequestInit) => Promise<Response>;
    /** The EventSource class to use to open up the SSE connection */
    eventSourceClass?: {
        new (url: string, eventSourceInitDict?: EventSourceInit | undefined): EventSource;
        prototype: EventSource;
        readonly CLOSED: number;
        readonly CONNECTING: number;
        readonly OPEN: number;
    };
    /** The base URL to use to perform the query (defaults to `https://graphql-listen.datocms.com`) */
    baseUrl?: string;
    /** Callback function to call on status change */
    onStatusChange?: (status: ConnectionStatus) => void;
    /** Callback function to call on query result updates */
    onUpdate: (updateData: UpdateData<QueryResult>) => void;
    /** Callback function to call on channel errors */
    onChannelError?: (errorData: ChannelErrorData) => void;
    /** Callback function to call on other errors */
    onError?: (errorData: MessageEvent) => void;
    /** Callback function to call on events during the connection lifecycle */
    onEvent?: (eventData: EventData) => void;
};
export declare type UnsubscribeFn = () => void;
export declare class Response500Error extends Error {
    response: Response;
    constructor(message: string, response: Response);
}
export declare class Response400Error extends Error {
    response: Response;
    constructor(message: string, response: Response);
}
export declare class InvalidResponseError extends Error {
    response: Response;
    constructor(message: string, response: Response);
}
export declare function subscribeToQuery<QueryResult = any, QueryVariables = Record<string, any>>(options: Options<QueryResult, QueryVariables>): Promise<UnsubscribeFn>;
